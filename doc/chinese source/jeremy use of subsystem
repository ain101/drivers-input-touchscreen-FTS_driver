//http://blog.csdn.net/tigerlau225/article/details/9748517

版权声明：本文为博主原创文章，未经博主允许不得转载。
Tp驱动中input子系统使用的分析。Android下Tp的流程如下：Tp -> i2c->host host通过i2c总线读取到数据后通过上报input事件将读到的数据上报给上层。Input子系统具体使用如下：probe函数中 ： struct input_dev *input_dev; // 定义指向input设备的指针struct input_dev定义如下，这是个大大的结构体，但别害怕。你关心的就只几个成员。（这东西可单独弄篇说明了见文档。。。）。 input_dev = input_allocate_device(); // 为input设备分配内存空间. 完全的系统调用，知道是干什么的怎么用的就行了。touch->idev = input_dev; //if input_dev represent an input devcie， than touch represent a touch devcie. touch->idev->name = "ft5306-ts"; // named the input device used for tp input_dev->id.bustype = BUS_I2C; //assigned bus type BUS_I2C macro is defined as 0x18 in input.hinput_dev->dev.parent = &client->dev; //assigned value input device's member basic device dev's member parent usually the bus which hosts the device. Here is ....（not clear myself）.Continue... __set_bit(EV_ABS, input_dev->evbit);//evbit：这个数组以位掩码的形式，代表这个input设备支持事件的类型。EV_ABS支持绝对值上报事件。 __set_bit(EV_SYN, input_dev->evbit);//EV_SYN支持同步事件 __set_bit(ABS_MT_POSITION_X, input_dev->absbit);//这个数组以位掩码的形式，代表这个这个事件支持的编码。ABS_MT_POSITION_X支持多点触摸的x坐标上报 __set_bit(ABS_MT_POSITION_Y, input_dev->absbit);//ABS_MT_POSITION_Y支持多点触摸的y坐标上报 input_mt_init_slots(input_dev, MAX_FINGER);// This function allocates all necessary memory for MT slot handling in the input device, prepares the ABS_MT_SLOT and ABS_MT_TRACKING_ID events for use and sets up appropriate buffers. 较新一点的这个函数加了第三个参数unsigned int flags，我这里是旧一点的。 input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0, maxx, 0, 0); input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0, maxy, 0, 0); input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, 16, 0, 0);//上面的__set_bit设置了支持事件的类型（比如abs事件，abs事件的x，y坐标等）。input_set_abs_params用来设置具体事件的参数。 比如input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0, maxx, 0, 0); 设置x事件上报的最小值为0，最大值为maxx，最后的两个参数分别叫fuzz和flat， i am not clear myself, in multi-touch input event 0,0 will be ok. ABS_MT_TOUCH_MAJOR this one En。。。Set param of Major axis of touching ellipse（椭圆）为什么叫touching ellipse，因为虽然上报的是坐标值(一个点)，但实际手指触摸的时候肯定是个接触面（所以上报的x，y值是接触面的中心，how the center of touching ellipse determined？I am not clear），接触面可以被粗略的认为是个椭圆，所以就叫touching ellipse了。ABS_MT_TOUCH_MAJOR即指接触面椭圆的长轴。相应的有ABS_MT_TOUCH_MINOR就不解释了。Linux源码包中 document/input目录下的几个txt中说的很清楚。Continue。。。ret = input_register_device(touch->idev);只说一下功能，从函数名能猜到 register device with input core.详解待以后。Probe函数中的input设备相关操作完成。接下来在static void ft5306_touch_work(struct work_struct *work)函数中要实际利用probe中注册的input设备来完成数据的上报了。这个驱动是给hp的pad做的，ic是focaltech的ft5606，最多支持10个点，这个项目用到5个，每个点的位置信息在驱动中可以解析出来。所以用的是multi-touch的b协议。既然有b协议，那首先应该有个a协议。这两者什么区别？See the article under the the hierarchy. 根据文档协议b： a minimal event sequence for a two-contact touch would looklike for a type B device:ABS_MT_SLOT 0 ABS_MT_TRACKING_ID 45 ABS_MT_POSITION_X x[0] ABS_MT_POSITION_Y y[0] ABS_MT_SLOT 1 ABS_MT_TRACKING_ID 46 ABS_MT_POSITION_X x[1] ABS_MT_POSITION_Y y[1] SYN_REPORT又根据文档Event Usage小结的最后一段：In the type B protocol, ABS_MT_TOOL_TYPE and ABS_MT_TRACKING_ID areimplicitly handled by input core; drivers should instead callinput_mt_report_slot_state().这个函数中最后调用的也还是ABS_MT_TOOL_TYPE和ABS_MT_TRACKING_ID.然后再看我们的程序，for循环中input_mt_slot(input_dev, pi); input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, status); 如果状态是按下则有：input_report_abs(input_dev, ABS_MT_POSITION_X, px);input_report_abs(input_dev, ABS_MT_POSITION_Y, py);input_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, 16);一波数据完了（for循环完成）最后接一个:input_sync(input_dev); 怎么样？跟协议对应起来了吧？再看看抬起的动作，（这个我不太清楚了），再细说一下input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, status); 这个调用吧，这个弄清楚了，抬起动作的上报应该就清楚了。再抄一下https://www.kernel.org/doc/下面的东西了。原型：void input_mt_report_slot_state (struct input_dev * dev, unsigned int tool_type, bool active);功能： report contact state参数：devinput device with allocated MT slotstool_typethe tool type to use in this slot 我们用的是MT_TOOL_FINGER表示是手指触摸了。可选的有MT_TOOL_PEN这个就是表示触摸笔触摸咯。activetrue if contact is active, false otherwise.看完就知道了，抬起动作就是最开始的两句话input_mt_slot(input_dev, pi); input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, status); 做的。由参数status来控制。Status在这两句的上面赋值， status = (POINT_PUTUP != ps);如果状态不是POINT_PUTUP则status为1，表示状态为put down或者是contact，如果是POINT_PUTUP即抬起，status就为0. 抬起动作就这样报上去的。 驱动中input设备相关的代码的分析就先这样吧。乱乱的初稿，得空一定会整理一下。  
