//http://blog.csdn.net/tigerlau225/article/details/9729803

struct input_dev {  
  const char * name;  // name of device  
  const char * phys;  //physical path to device in system hierarchy  
  const char * uniq; //unique identification code for the device  
  struct input_id id;//id of the device   
  unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];  
  //bitmap of device properties and quirks   
  unsigned long evbit[BITS_TO_LONGS(EV_CNT)];  
//bitmap of types of events supported by the device (EV_KEY, EV_REL, etc.)  
  unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];  
//bitmap of keys/buttons this device has  
  unsigned long relbit[BITS_TO_LONGS(REL_CNT)];  
//bitmap of relative axes for the device  
  unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];  
//bitmap of absolute axes for the device  
  unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];  
//bitmap of miscellaneous events supported by the device  
  unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];  
//bitmap of leds present on the device  
  unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];  
//bitmap of sound effects supported by the device  
  unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];  
//bitmap of force feedback effects supported by the device  
  unsigned long swbit[BITS_TO_LONGS(SW_CNT)];  
//bitmap of switches present on the device  
  unsigned int hint_events_per_packet;  
//average number of events generated by the device in a packet (between EV_SYN/SYN_REPORT events). Used by event handlers to estimate size of the buffer needed to hold events.  
  unsigned int keycodemax;  
//size of keycode table  
  unsigned int keycodesize;  
//size of elements in keycode table  
  void * keycode;  
//map of scancodes to keycodes for this device.  
  int (* setkeycode) (struct input_dev *dev,const struct input_keymap_entry *ke,unsigned int *old_keycode);  
//optional method to alter current keymap, used to implement sparse keymaps. If not supplied default mechanism will be used. The method is being called while holding event_lock and thus must not sleep  
  int (* getkeycode) (struct input_dev *dev,struct input_keymap_entry *ke);  
//optional legacy method to retrieve current keymap.  
  struct ff_device * ff;  
//force feedback structure associated with the device if device supports force feedback effects  
  unsigned int repeat_key;  
//stores key code of the last key pressed; used to implement software autorepeat  
  struct timer_list timer;  
//timer for software autorepeat  
  int rep[REP_CNT];  
//current values for autorepeat parameters (delay, rate)  
  struct input_mt * mt;  
//pointer to multitouch state  
  struct input_absinfo * absinfo;  
//array of struct input_absinfo elements holding information about absolute axes (current value, min, max, flat, fuzz, resolution)  
  unsigned long key[BITS_TO_LONGS(KEY_CNT)];  
//reflects current state of device's keys/buttons  
  unsigned long led[BITS_TO_LONGS(LED_CNT)];  
//reflects current state of device's LEDs  
  unsigned long snd[BITS_TO_LONGS(SND_CNT)];  
//reflects current state of sound effects  
  unsigned long sw[BITS_TO_LONGS(SW_CNT)];  
//reflects current state of device's switches  
  int (* open) (struct input_dev *dev);  
// this method is called when the very first user calls input_open_device. The driver must prepare the device to start generating events (start polling thread, request an IRQ, submit URB, etc.)  
  void (* close) (struct input_dev *dev);  
//this method is called when the very last user calls input_close_device.  
  int (* flush) (struct input_dev *dev, struct file *file);  
//purges the device. Most commonly used to get rid of force feedback effects loaded into the device when disconnecting from it  
  int (* event) (struct input_dev *dev, unsigned int type, unsigned int code, int value);  
//event handler for events sent _to_ the device, like EV_LED or EV_SND. The device is expected to carry out the requested action (turn on a LED, play sound, etc.) The call is protected by event_lock and must not sleep  
  struct input_handle __rcu * grab;  
//input handle that currently has the device grabbed (via EVIOCGRAB ioctl). When a handle grabs a device it becomes sole recipient for all input events coming from the device  
  spinlock_t event_lock;  
//this spinlock is is taken when input core receives and processes a new event for the device (in input_event). Code that accesses and/or modifies parameters of a device (such as keymap or absmin, absmax, absfuzz, etc.) after device has been registered with input core must take this lock.  
  struct mutex mutex;  
//serializes calls to open, close and flush methods  
  unsigned int users;  
//stores number of users (input handlers) that opened this device. It is used by input_open_device and input_close_device to make sure that dev->openis only called when the first user opens device and dev->close is called when the very last user closes the device  
  bool going_away;  
//marks devices that are in a middle of unregistering and causes input_open_device*() fail with -ENODEV.  
  struct device dev;  
//driver model's view of this device  
  struct list_head h_list;  
//list of input handles associated with the device. When accessing the list dev->mutex must be held.  
  struct list_head node;  
//used to place the device onto input_dev_list  
  unsigned int num_vals;  
//number of values queued in the current frame  
  unsigned int max_vals;  
//maximum number of values queued in a frame  
  struct input_value * vals;  
//array of values queued in the current frame  
  bool devres_managed;  
//indicates that devices is managed with devres framework and needs not be explicitly unregistered or freed.  
};   
